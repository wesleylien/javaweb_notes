## 数据库的并发问题
多个事务同时访问数据库中相同的数据时，如果没有采取必要的隔离机制，就可能会发生如下**并发问题**：
* **第一类丢失更新（回滚覆盖）**：两个事务都更新同一个行，而另一个事务异常回滚，导致两处变化都丢失      
写操作没加“持续-X锁”，没能阻止事务B写，发生了回滚覆盖    
如 A , B 都开始事务，且都查询到字段的值为 1，B 先将字段值从 1 修改为 2 并提交事务，A 再将字段值从 1 修改为 0，导致异常回滚，回滚到值为 1，此时 A 和 B 的变化都丢失
* **脏读**：一个事务读取到另一个事务尚未提交的更改数据
* **不可重复读**：一个事务两次读取同一行数据，两次的状态不同
* **第二类丢失更新（提交覆盖）**：一个事务覆盖另一个事务已经提交的数据    
写操作加了“持续-X锁”，读操作加了“临时-S锁”，没能阻止事务B写，发生了提交覆盖    
如 A , B 都开始事务，且都查询到字段的值为 1，B 先将字段值从 1 修改为 2 并提交事务，A 再将字段值从 1 修改为 0 并提交事务，此时 B 的变化丢失
* **幻读**：一个事务前后执行一个查询两次，在第二个结果集中包括第一个结果集中不可见的行，或者包括已经删除的行时

## 事务的隔离级别
为了解决多个事务并发会引发的问题，让用户根据需要在事务的隔离性和并发性之间做合理的权衡，数据库系统提供了**四种事务隔离级别**供用户选择
* **Read Uncommitted（读未提交数据）**—— 事务读不阻塞其他事务读和写，事务写阻塞其他事务写但不阻塞读。可以通过写操作加“持续-X锁”实现。不允许第一类更新丢失。允许脏读，不隔离事务
* **Read Committed（读已提交数据）**—— 事务读不会阻塞其他事务读和写，事务写会阻塞其他事务读和写。可以通过写操作加“持续-X”锁，读操作加“临时-S锁”实现。不允许脏读，允许不可重复读。Oracle 的默认隔离级别
* **Repeatable Read（可重复读）**—— 事务读会阻塞其他事务事务写但不阻塞读，事务写会阻塞其他事务读和写。可以通过写操作加“持续-X”锁，读操作加“持续-S锁”实现。不允许不可重复读。但可能出现幻读。MySQL 的默认隔离级别
* **Serializable（串行化）**—— “行级锁”做不到，需使用“表级锁”。所有的增删改查串行执行


事务隔离级别 | 第一类丢失更新 | 脏读 | 不可重复读 | 第二类丢失更新 | 幻读
---|---|---|---|---|---
Read Uncommitted | x | 可能发生 | 可能发生  | 可能发生  | 可能发生
Read Committed | x | x | 可能发生  | 可能发生  | 可能发生
Repeatable Read | x | x | x  | x  | 可能发生
Serializable | x | x | x  | x  | x

## 常用的解决方案
### 共享锁与排它锁
#### 共享锁（Shared locks, S-locks）
共享锁是基本锁类型之一，也称读锁

加共享锁的对象只允许被当前事务和其他事务读

能给未加锁和添加了S锁的对象添加S锁

对象可以接受添加多把S锁

#### 排它锁（Exclusive locks, X-locks）
排它锁是基本锁类型之一，也称独占锁，写锁

加排它锁的对象只允许被当前事务读和写

只能给未加锁的对象添加X锁

对象只能接受一把X锁

加X锁的对象不能再加任何锁

#### 更新锁（Update locks, U-locks）
更新锁是锁类型之一

引入更新锁是因为多数数据库在实现加X锁时是执行了如下流程：先加S锁，添加成功后尝试更换为X锁。这时如果有两个事务同时加了S锁，尝试换X锁，就会发生死锁。因此增加U锁，U锁代表有更新意向，只允许有一个事务拿到U锁，该事务在发生写后U锁变X锁，未写时看做S锁

目前好像只在 MSSQL 里看到了U锁

### 锁的时效性
根据锁的时效性有**临时锁**与**持续锁**，指明了加锁生效期是到当前语句结束还是当前事务结束

### 锁的粒度
根据锁的粒度有**表级锁**与**行级锁**，指明了加锁的对象是当前表还是当前行

### 乐观锁与悲观锁（Pessimistic Locking）
悲观锁与乐观锁这两种锁的说法，主要是对“是否真正在数据库层面加锁”进行讨论

#### 乐观锁（Optimistic Locking）
乐观锁假定当前事务操纵数据资源时，不会有其他事务同时访问该数据资源，因此**不在数据库层次上的锁定**

**乐观锁使用由程序逻辑控制的技术** 来避免可能出现的并发问题

唯一能够同时保持高并发和高可伸缩性的方法就是使用带版本检查的乐观锁

乐观锁的原理，也就是在数据库的表中，加入版本号的字段，在读取数据时，连同版本号一起读取，在更新数据时，首先比较新数据的版本号与表中的版本号是否相同，如果相同则给予更新，且自动递增版本号；如果小雨数据库版本号，则抛出异常

乐观锁不能解决脏读的问题，因此仍需要数据库至少启用“Read Committed”的事务隔离级别

在企业开发中：Read committed + 乐观锁 -> Repeatable Read


#### 悲观锁（Pessimistic Locking）
悲观锁假定当前事务操纵数据资源时，肯定还会有其他事务同时访问该数据资源，为了避免当前事务的操作受到干扰，先锁定资源

**悲观锁需使用数据库的锁机制实现**，如使用行级排他锁或表级排它锁

尽管悲观锁能够防止丢失更新和不可重复读这类问题，但是它非常影响并发性能，因此应该谨慎使用

### 三级加锁协议
三级加锁协议称之为协议，是指在使用它的时候，**所有的事务都必须遵循该规则**

1. 一级加锁协议    
事务在修改数据前必须加X锁，直到事务结束（提交或终止）才可释放；如果仅仅是读数据，不需要加锁。如：
    ```
    SELECT xxx FOR UPDATE;
    UPDATE xxx;
    ```
2. 二级加锁协议      
  满足一级加锁协议，且事务在读取数据之前必须先加S锁，读完后即可释放S锁
3. 三级加锁协议     
  满足一级加锁协议，且事务在读取数据之前必须先加S锁，直到事务结束才释放

### 两段锁协议（2-phase locking）
* 加锁阶段：事务在读数据前加S锁，写数据前加X锁，加锁不成功则等待
* 解锁阶段：一旦开始释放锁，就不允许再加锁了

若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的

遵循两段锁协议的事务调度处理的结果是可串行化的充分条件，但是可串行化并不一定遵循两段锁协议

#### 两段锁协议和防止死锁的一次封锁法的异同之处
1. 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议
2. 但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁

## 不同的事务隔离级别与其对应可选择的加锁协议

事务隔离级别 | 加锁协议
---|---
Read Uncommitted | 一级加锁协议
Read Committed | 二级加锁协议
Repeatable Read | 三级加锁协议
Serializable | 两段锁协议

但加锁协议和隔离级别并不是严格对应的
